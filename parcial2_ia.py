# -*- coding: utf-8 -*-
"""Parcial2_IA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AK_T8zMgYNMskCZDBu2fNfOd4zBIuPJA
"""

import numpy as np

def crear_dominio_estructural(x, y, z):
    """
    Esta función genera un arreglo tridimensional que representa un dominio estructural simple.

    Parámetros:
    x (int): dimension en el eje X
    y (int): dimension en el eje Y
    z (int): dimension en el eje Z

    Retorna:
    np.array: Arreglo tridimensional de ceros
    """
    # Crear un arreglo tridimensional lleno de ceros
    dominio = np.zeros((x, y, z))
    return dominio

# Ejemplo de uso de la función
dominio = crear_dominio_estructural(10, 10, 10)
print(dominio)

!pip install pyvista

import numpy as np
import pyvista as pv

def exportar_a_paraview(puntos, presiones, desplazamientos):
    # Asegurarse de que los puntos sean de tipo float
    puntos_float = np.array(puntos, dtype=np.float32)

    # Crear un objeto PolyData
    cloud = pv.PolyData(puntos_float)

    # Añadir los datos al objeto
    cloud["Presiones"] = presiones
    cloud["Desplazamientos"] = desplazamientos

    # Guardar el archivo en formato VTK
    cloud.save("resultados_estructurales.vtk")

# Ejemplo de uso de la función
puntos = [(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1)]  # Definidos como enteros
presiones = [100, 150, 90, 120]
desplazamientos = [0.1, 0.2, 0.1, 0.3]
exportar_a_paraview(puntos, presiones, desplazamientos)

import numpy as np

def calcular_tensor_deformacion(matriz_desplazamientos):
    """
    Esta función calcula el tensor de deformaciones para un elemento finito tetraédrico.

    Parámetros:
    matriz_desplazamientos (np.array): Matriz de desplazamientos nodales (4x3)

    Retorna:
    np.array: Tensor de deformaciones (3x3)
    """
    # Asumimos un simple ejemplo donde matriz_desplazamientos tiene 12 elementos (4 nodos x 3 desplazamientos por nodo)
    if matriz_desplazamientos.size != 12:
        raise ValueError("La matriz de desplazamientos debe ser de tamaño 4x3.")

    # Matriz B simplificada
    # Debe ser calculada basada en las coordenadas nodales y las propiedades del elemento
    B = np.random.random((6, 12))  # Dimensiones correctas para el cálculo del tensor en un espacio 3D

    # Multiplicación matricial
    deformaciones = B @ matriz_desplazamientos.flatten()  # Resultado debe tener 6 componentes

    # Retornar el tensor de deformaciones en forma matricial (3x2)
    # Nota: El tensor de deformaciones tiene solo 6 componentes independientes en 3D
    return deformaciones.reshape((3, 2))

# Ejemplo de uso de la función
matriz_desplazamientos = np.array([
    [0.0, 0.0, 0.0],
    [0.1, 0.0, 0.0],
    [0.0, 0.1, 0.0],
    [0.0, 0.0, 0.1]
])
tensor_deformacion = calcular_tensor_deformacion(matriz_desplazamientos)
print("Tensor de deformaciones:", tensor_deformacion)

!pip install meshpy

import numpy as np
import pyvista as pv

# Generación de malla básica de un prisma tetraédrico
def generar_malla():
    puntos = np.array([
        [0, 0, 0],  # Nodo 0
        [1, 0, 0],  # Nodo 1
        [0, 1, 0],  # Nodo 2
        [0, 0, 1]   # Nodo 3
    ])
    elementos = np.array([
        [0, 1, 2, 3]
    ])
    malla = pv.PolyData(puntos)
    malla.verts = elementos
    return malla, puntos, elementos

malla, puntos, elementos = generar_malla()

def ensamblar_matriz_rigidez(puntos, elementos):
    num_nodos = len(puntos)
    K_global = np.zeros((num_nodos*3, num_nodos*3))  # Matriz de rigidez 3D

    for elemento in elementos:
        K_local = np.random.random((12, 12))  # Matriz de rigidez local simplificada
        indices = np.ravel([[3*i, 3*i+1, 3*i+2] for i in elemento])
        for i in range(12):
            for j in range(12):
                K_global[indices[i], indices[j]] += K_local[i, j]

    return K_global

K_global = ensamblar_matriz_rigidez(puntos, elementos)

from scipy.sparse.linalg import spsolve
from scipy.sparse import csr_matrix

def resolver_sistema(K, F):
    K_sparse = csr_matrix(K)  # Uso de matriz dispersa para eficiencia
    desplazamientos = spsolve(K_sparse, F)
    return desplazamientos

F = np.random.random(len(puntos) * 3)  # Vector de fuerzas aleatorio
desplazamientos = resolver_sistema(K_global, F)

def exportar_paraview(puntos, desplazamientos):
    # Crear una estructura PolyData con los puntos
    malla = pv.PolyData(puntos)

    # Asegurarse de que los desplazamientos sean un array numpy adecuado
    desplazamientos_np = np.array(desplazamientos).reshape(-1, 3)

    # Asignar los desplazamientos como datos de los puntos en la malla
    malla.point_data['Desplazamientos'] = desplazamientos_np

    # Guardar la malla en un archivo VTK para visualización en Paraview
    malla.save("estructura_desplazamientos.vtk")

# Ejemplo de uso de la función corregida
exportar_paraview(puntos, desplazamientos)

import vtk
from vtk.util.numpy_support import vtk_to_numpy
import pandas as pd

def vtk_to_csv(vtk_file, csv_file):
    # Leer el archivo VTK
    reader = vtk.vtkGenericDataObjectReader()
    reader.SetFileName(vtk_file)
    reader.Update()

    # Obtener el output
    output = reader.GetOutput()

    # Asegurar que haya puntos
    if not output.GetPoints():
        raise ValueError("No points in VTK data.")

    # Extraer los puntos
    points = vtk_to_numpy(output.GetPoints().GetData())
    # Los puntos son un array con forma (n, 3), necesitamos dividirlo en X, Y, Z
    df = pd.DataFrame(data=points, columns=['X', 'Y', 'Z'])

    # Si hay datos escalares, añadirlos al DataFrame
    if output.GetPointData().GetNumberOfArrays() > 0:
        scalars = vtk_to_numpy(output.GetPointData().GetScalars())
        # Verificar que los scalars son 1D
        if len(scalars.shape) > 1 and scalars.shape[1] != 1:
            raise ValueError("Scalars array is not 1D.")
        df['Scalars'] = scalars.flatten()  # Aplanar para asegurar que sea 1D si es necesario

    # Guardar a CSV
    df.to_csv(csv_file, index=False)
    print(f"Saved to {csv_file}")

# Usar la función
vtk_to_csv("path_to_your_file.vtk", "output_file.csv")